name: Index Management

on:
  push:
    branches: [ main ]
    paths:
      - '**/*.py'
      - '**/*.js'
      - '**/*.ts'
      - '**/*.md'
      - '**/*.java'
      - '**/*.go'
      - '**/*.rs'
      - '**/*.c'
      - '**/*.cpp'
      - '**/*.h'
      - '**/*.hpp'
      - '**/*.cs'
      - '**/*.swift'
      - '**/*.kt'
      - '**/*.dart'
      - '**/*.html'
      - '**/*.css'
  pull_request:
    branches: [ main ]
    paths:
      - '**/*.py'
      - '**/*.js'
      - '**/*.ts'
      - '**/*.md'
      - '**/*.java'
      - '**/*.go'
      - '**/*.rs'
      - '**/*.c'
      - '**/*.cpp'
      - '**/*.h'
      - '**/*.hpp'
      - '**/*.cs'
      - '**/*.swift'
      - '**/*.kt'
      - '**/*.dart'
      - '**/*.html'
      - '**/*.css'
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild all indexes'
        required: false
        default: 'false'
        type: boolean

env:
  PYTHON_VERSION: '3.11'

jobs:
  check-index-compatibility:
    name: Check Index Compatibility
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    outputs:
      compatible: ${{ steps.check.outputs.compatible }}
      needs_rebuild: ${{ steps.check.outputs.needs_rebuild }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Check index compatibility
        id: check
        run: |
          python -c "
          from mcp_server.utils.semantic_indexer import SemanticIndexer
          import os
          import json
          
          indexer = SemanticIndexer()
          compatible = indexer.check_compatibility()
          
          print(f'Index compatibility: {compatible}')
          
          # Check if significant source changes occurred
          import subprocess
          result = subprocess.run(['git', 'diff', '--name-only', 'origin/main...HEAD'], 
                                capture_output=True, text=True)
          changed_files = result.stdout.strip().split('\n') if result.stdout.strip() else []
          
          source_files = [f for f in changed_files if f.endswith(('.py', '.js', '.ts', '.md', '.java', '.go', '.rs', '.c', '.cpp', '.h', '.hpp', '.cs', '.swift', '.kt', '.dart', '.html', '.css'))]
          
          needs_rebuild = len(source_files) > 0 or not compatible
          
          print(f'Changed source files: {len(source_files)}')
          print(f'Needs rebuild: {needs_rebuild}')
          
          # Set outputs
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f'compatible={str(compatible).lower()}\n')
              f.write(f'needs_rebuild={str(needs_rebuild).lower()}\n')
          "

      - name: Comment on PR if incompatible
        if: steps.check.outputs.compatible == 'false'
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `⚠️ **Index Compatibility Warning**
              
              The current index artifacts use a different embedding model or configuration than your changes.
              
              **Options:**
              1. The index will be automatically rebuilt after merge
              2. You can manually rebuild by commenting \`/rebuild-index\` on this PR
              
              This ensures optimal search performance with your changes.`
            })

  rebuild-indexes:
    name: Rebuild Indexes
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && inputs.force_rebuild == 'true') ||
      (github.event_name == 'pull_request' && needs.check-index-compatibility.outputs.needs_rebuild == 'true')
    needs: [check-index-compatibility]
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Setup Qdrant for indexing
        run: |
          # Create directory for Qdrant storage
          mkdir -p vector_index.qdrant

      - name: Backup existing indexes
        run: |
          if [ -f "code_index.db" ]; then
            cp code_index.db code_index.db.backup
          fi
          if [ -d "vector_index.qdrant" ]; then
            cp -r vector_index.qdrant vector_index.qdrant.backup
          fi

      - name: Rebuild SQLite index
        run: |
          python -c "
          import os
          import logging
          from mcp_server.storage.sqlite_store import SQLiteStore
          from mcp_server.dispatcher.dispatcher import Dispatcher
          
          logging.basicConfig(level=logging.INFO)
          
          # Remove old index if exists
          if os.path.exists('code_index.db'):
              os.remove('code_index.db')
          
          # Initialize new index
          store = SQLiteStore('code_index.db')
          dispatcher = Dispatcher(store)
          
          # Index all supported files
          import glob
          from pathlib import Path
          
          patterns = ['**/*.py', '**/*.js', '**/*.ts', '**/*.md', '**/*.java', 
                     '**/*.go', '**/*.rs', '**/*.c', '**/*.cpp', '**/*.h', 
                     '**/*.hpp', '**/*.cs', '**/*.swift', '**/*.kt', 
                     '**/*.dart', '**/*.html', '**/*.css']
          
          files_indexed = 0
          for pattern in patterns:
              for file_path in glob.glob(pattern, recursive=True):
                  if 'test_repos' in file_path or '.git' in file_path:
                      continue
                  try:
                      result = dispatcher.index_file(file_path)
                      if result and result.get('symbols_found', 0) > 0:
                          files_indexed += 1
                          if files_indexed % 100 == 0:
                              print(f'Indexed {files_indexed} files...')
                  except Exception as e:
                      print(f'Error indexing {file_path}: {e}')
          
          print(f'Completed indexing {files_indexed} files')
          "

      - name: Rebuild vector index
        env:
          SEMANTIC_SEARCH_ENABLED: "true"
          VOYAGE_AI_API_KEY: ${{ secrets.VOYAGE_AI_API_KEY }}
        run: |
          python -c "
          import os
          import logging
          from mcp_server.utils.semantic_indexer import SemanticIndexer
          import glob
          
          if not os.getenv('VOYAGE_AI_API_KEY'):
              print('VOYAGE_AI_API_KEY not available, skipping vector indexing')
              exit(0)
          
          logging.basicConfig(level=logging.INFO)
          
          # Remove old vector index
          import shutil
          if os.path.exists('vector_index.qdrant'):
              shutil.rmtree('vector_index.qdrant')
          
          # Initialize semantic indexer
          indexer = SemanticIndexer()
          
          # Index Python files as example
          python_files = glob.glob('**/*.py', recursive=True)
          python_files = [f for f in python_files if 'test_repos' not in f and '.git' not in f]
          
          files_indexed = 0
          for file_path in python_files[:100]:  # Limit for CI performance
              try:
                  from pathlib import Path
                  result = indexer.index_file(Path(file_path))
                  files_indexed += 1
                  if files_indexed % 10 == 0:
                      print(f'Vector indexed {files_indexed} files...')
              except Exception as e:
                  print(f'Error vector indexing {file_path}: {e}')
          
          print(f'Completed vector indexing {files_indexed} files')
          "

      - name: Validate rebuilt indexes
        run: |
          python -c "
          import os
          from mcp_server.storage.sqlite_store import SQLiteStore
          from mcp_server.utils.semantic_indexer import SemanticIndexer
          
          # Test SQLite index
          if os.path.exists('code_index.db'):
              store = SQLiteStore('code_index.db')
              print('✓ SQLite index validated')
          else:
              print('✗ SQLite index missing')
              exit(1)
          
          # Test vector index
          if os.path.exists('vector_index.qdrant'):
              try:
                  indexer = SemanticIndexer()
                  print('✓ Vector index validated')
              except Exception as e:
                  print(f'✗ Vector index validation failed: {e}')
          else:
              print('⚠ Vector index not created (API key may be missing)')
          
          # Check metadata
          if os.path.exists('.index_metadata.json'):
              print('✓ Index metadata validated')
          else:
              print('✗ Index metadata missing')
              exit(1)
          "

      - name: Commit updated indexes
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Add index artifacts
          git add code_index.db || true
          git add vector_index.qdrant/ || true
          git add .index_metadata.json || true
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No index changes to commit"
          else
            git commit -m "chore: update index artifacts

            - Rebuilt SQLite index with latest symbols
            - Updated vector embeddings for semantic search
            - Refreshed index metadata for compatibility

            🤖 Automated index update"
            
            git push
          fi

      - name: Cleanup on failure
        if: failure()
        run: |
          # Restore backups if available
          if [ -f "code_index.db.backup" ]; then
            mv code_index.db.backup code_index.db
          fi
          if [ -d "vector_index.qdrant.backup" ]; then
            rm -rf vector_index.qdrant
            mv vector_index.qdrant.backup vector_index.qdrant
          fi

  validate-pr-indexes:
    name: Validate PR Index Changes
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: [check-index-compatibility]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Test index functionality
        run: |
          python -c "
          import os
          from mcp_server.storage.sqlite_store import SQLiteStore
          
          if os.path.exists('code_index.db'):
              store = SQLiteStore('code_index.db')
              print('✓ Can load existing SQLite index')
              
              # Test basic functionality
              with store._get_connection() as conn:
                  cursor = conn.execute('SELECT COUNT(*) FROM symbols')
                  symbol_count = cursor.fetchone()[0]
                  print(f'✓ Found {symbol_count} symbols in index')
          else:
              print('ℹ No existing SQLite index found')
          
          # Test semantic indexer compatibility
          from mcp_server.utils.semantic_indexer import SemanticIndexer
          indexer = SemanticIndexer()
          compatible = indexer.check_compatibility()
          print(f'✓ Index compatibility check: {compatible}')
          "

      - name: Comment validation results
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `✅ **Index Validation Complete**
              
              Your changes have been validated against the existing index artifacts.
              
              - SQLite index: Functional
              - Vector index compatibility: Checked
              - Ready for merge without reindexing delays
              
              After merge, indexes will be automatically updated if needed.`
            })