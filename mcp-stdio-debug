#!/usr/bin/env python3
"""
Debug wrapper for MCP stdio server to trace communication issues
"""
import sys
import json
import subprocess
import select
import time
import os
from datetime import datetime

LOG_FILE = f"/tmp/mcp-stdio-debug-{int(time.time())}.log"

def log(msg):
    with open(LOG_FILE, 'a') as f:
        f.write(f"[{datetime.now().isoformat()}] {msg}\n")
    print(f"[DEBUG] {msg}", file=sys.stderr)

def main():
    log(f"MCP stdio debug wrapper started")
    log(f"Working directory: {os.getcwd()}")
    log(f"Python: {sys.executable}")
    
    # Set up environment
    env = os.environ.copy()
    env.update({
        "MCP_DISABLE_RESOURCES": "true",
        "PYTHONPATH": os.getcwd(),
        "LOG_LEVEL": "INFO",
        "DATABASE_URL": f"sqlite:///{os.getcwd()}/code_index.db",
        "PLUGIN_STARTUP_MODE": "minimal",
        "MCP_FAST_STARTUP": "true",
        "STARTUP_TIMEOUT": "20",
        "PYTHONUNBUFFERED": "1"
    })
    
    # Start the MCP server process
    cmd = [sys.executable, "-m", "mcp_server", "--transport", "stdio"]
    log(f"Starting command: {' '.join(cmd)}")
    
    proc = subprocess.Popen(
        cmd,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=env,
        bufsize=0,  # Unbuffered
        universal_newlines=False  # Binary mode
    )
    
    log(f"Process started with PID: {proc.pid}")
    
    # Set non-blocking mode
    import fcntl
    flags = fcntl.fcntl(sys.stdin, fcntl.F_GETFL)
    fcntl.fcntl(sys.stdin, fcntl.F_SETFL, flags | os.O_NONBLOCK)
    
    flags = fcntl.fcntl(proc.stdout, fcntl.F_GETFL)
    fcntl.fcntl(proc.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)
    
    flags = fcntl.fcntl(proc.stderr, fcntl.F_GETFL)
    fcntl.fcntl(proc.stderr, fcntl.F_SETFL, flags | os.O_NONBLOCK)
    
    # Main loop
    while proc.poll() is None:
        readable, _, _ = select.select([sys.stdin, proc.stdout, proc.stderr], [], [], 0.1)
        
        # Handle stdin -> process
        if sys.stdin in readable:
            try:
                data = sys.stdin.buffer.read()
                if data:
                    log(f"STDIN -> Process: {data}")
                    proc.stdin.write(data)
                    proc.stdin.flush()
            except Exception as e:
                log(f"Error reading stdin: {e}")
        
        # Handle process stdout -> stdout
        if proc.stdout in readable:
            try:
                data = proc.stdout.read()
                if data:
                    log(f"Process -> STDOUT: {data}")
                    sys.stdout.buffer.write(data)
                    sys.stdout.flush()
            except Exception as e:
                log(f"Error reading process stdout: {e}")
        
        # Handle process stderr -> log
        if proc.stderr in readable:
            try:
                data = proc.stderr.read()
                if data:
                    log(f"Process STDERR: {data}")
            except Exception as e:
                log(f"Error reading process stderr: {e}")
    
    exit_code = proc.returncode
    log(f"Process exited with code: {exit_code}")
    log(f"Debug log saved to: {LOG_FILE}")
    
    return exit_code

if __name__ == "__main__":
    sys.exit(main())